<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Semana 3: Teor√≠a de Grafos ‚Äì Representaci√≥n y Modelado [CORREGIDO]</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{
      font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height:1.6;color:#2c3e50;
      background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%);
      min-height:100vh
    }
    .container{max-width:1200px;margin:0 auto;padding:20px}
    header{
      text-align:center;margin-bottom:40px;background:#fff;
      padding:30px;border-radius:15px;
      box-shadow:0 10px 30px rgba(0,0,0,0.1)
    }
    h1{font-size:2.4em;margin-bottom:8px}
    .subtitle{font-size:1.1em;color:#7f8c8d;font-weight:300}
    nav{
      background:#fff;padding:15px;border-radius:10px;margin-bottom:30px;
      box-shadow:0 5px 15px rgba(0,0,0,0.08);position:sticky;top:20px;z-index:100
    }
    nav ul{list-style:none;display:flex;justify-content:center;flex-wrap:wrap;gap:12px}
    nav a{text-decoration:none;color:#34495e;padding:10px 18px;border-radius:22px;transition:all .3s ease;font-weight:500}
    nav a:hover, nav a.active{background:#3498db;color:#fff;transform:translateY(-2px)}
    .section{background:#fff;margin-bottom:30px;padding:28px;border-radius:15px;box-shadow:0 8px 25px rgba(0,0,0,0.1);display:none}
    .section.active{display:block}
    .section h2{color:#2c3e50;margin-bottom:18px;font-size:1.7em;border-bottom:3px solid #3498db;padding-bottom:8px}
    .section h3{color:#34495e;margin:20px 0 12px;font-size:1.3em}
    .challenge{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;padding:18px;border-radius:10px;margin:18px 0}
    .activity{background:#f8f9fa;border-left:5px solid #28a745;padding:18px;margin:18px 0;border-radius:0 8px 8px 0}
    .activity h4{color:#28a745;margin-bottom:8px}
    .error-box{background:#fff5f5;border-left:5px solid #e74c3c;padding:18px;margin:18px 0;border-radius:0 8px 8px 0}
    .error-box h4{color:#e74c3c;margin-bottom:8px}
    .code-container{background:#2c3e50;border-radius:10px;overflow:hidden;margin:18px 0;box-shadow:0 5px 15px rgba(0,0,0,0.2)}
    .code-header{background:#34495e;color:#fff;padding:10px 16px;font-weight:bold;display:flex;justify-content:space-between;align-items:center}
    .code-content{padding:18px;color:#ecf0f1;font-family:'Courier New', monospace;font-size:14px;line-height:1.6;overflow-x:auto;white-space:pre}
    .keyword{color:#3498db}.string{color:#e74c3c}.comment{color:#95a5a6;font-style:italic}.number{color:#f39c12}
    .comparison-table{width:100%;border-collapse:collapse;margin:16px 0;overflow:hidden;border-radius:10px;box-shadow:0 5px 15px rgba(0,0,0,0.1)}
    .comparison-table th,.comparison-table td{padding:14px;text-align:left;border-bottom:1px solid #e9ecef}
    .comparison-table th{background:#3498db;color:#fff;font-weight:600}
    .comparison-table tr:nth-child(even){background:#f8f9fa}
    .progress-bar{background:#ecf0f1;height:6px;border-radius:3px;margin-top:14px;overflow:hidden}
    .progress-fill{background:linear-gradient(90deg,#3498db,#2ecc71);height:100%;width:0%;transition:width .3s ease}
    .btn{background:#3498db;color:#fff;border:none;padding:11px 22px;border-radius:24px;cursor:pointer;font-size:15px;transition:all .3s ease;margin:8px 4px}
    .btn:hover{background:#2980b9;transform:translateY(-2px);box-shadow:0 5px 15px rgba(52,152,219,0.4)}
    .btn-success{background:#27ae60}.btn-success:hover{background:#229954}
    .tag{display:inline-block;background:#eef6ff;color:#1f5faa;border:1px solid #cfe3ff;border-radius:999px;padding:4px 10px;margin:4px 6px 0 0;font-size:12px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    .note{font-size:.95em;color:#566573;padding:12px;background:#f8f9fa;border-radius:6px;margin:12px 0;white-space: pre-wrap;}
    ul,ol{margin-left:20px;margin-top:10px}
    li{margin-bottom:8px}
    @media (max-width: 900px){.grid{grid-template-columns:1fr}}
    .fade-in{animation:fadeIn .6s ease-in}
    @keyframes fadeIn{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üåê Semana 3 ‚Äì Teor√≠a de Grafos: Representaci√≥n y Modelado</h1>
      <p class="subtitle">V√©rtices, aristas, grados y c√≥mo elegir la representaci√≥n correcta</p>
      <p>Estructuras de Datos Avanzadas ¬© 2025 | <strong>Versi√≥n Corregida</strong></p>
      <div class="progress-bar"><div class="progress-fill" id="progress"></div></div>
      <div style="margin-top:10px">
        <span class="tag">Grafos</span>
        <span class="tag">Matriz de Adyacencia</span>
        <span class="tag">Lista de Adyacencia</span>
        <span class="tag">Modelado</span>
        <span class="tag">An√°lisis de Trade-offs</span>
      </div>
    </header>

    <nav>
      <ul>
        <li><a href="#" onclick="showSection('introduccion')" class="nav-link active">Introducci√≥n</a></li>
        <li><a href="#" onclick="showSection('conceptos')" class="nav-link">Conceptos</a></li>
        <li><a href="#" onclick="showSection('representaciones')" class="nav-link">Representaciones</a></li>
        <li><a href="#" onclick="showSection('problema')" class="nav-link">Problema</a></li>
        <li><a href="#" onclick="showSection('cs')" class="nav-link">Soluci√≥n C#</a></li>
        <li><a href="#" onclick="showSection('py')" class="nav-link">Soluci√≥n Python</a></li>
        <li><a href="#" onclick="showSection('actividades')" class="nav-link">Actividades</a></li>
        <li><a href="#" onclick="showSection('comparacion')" class="nav-link">Comparaci√≥n</a></li>
        <li><a href="#" onclick="showSection('proyecto')" class="nav-link">Proyecto</a></li>
      </ul>
    </nav>

    <!-- INTRODUCCI√ìN -->
    <section id="introduccion" class="section active fade-in">
      <h2>üéØ Objetivos de la Semana</h2>
      <div class="activity">
        <h4>¬øQu√© lograr√°s hoy?</h4>
        <ul>
          <li>Reconocer elementos de un grafo: v√©rtices, aristas, pesos, direcci√≥n.</li>
          <li>Comparar <strong>matriz</strong> vs <strong>lista de adyacencia</strong> con criterios de memoria y tiempo.</li>
          <li>Implementar una <strong>clase Grafo robusta</strong> en C# usando listas de adyacencia.</li>
          <li>Construir grafo en Python a partir de un <em>archivo de aristas</em>.</li>
          <li>Identificar y <strong>corregir errores comunes</strong> en implementaciones de grafos.</li>
        </ul>
      </div>
      <div class="challenge">
        <h3>Enfoque Pedag√≥gico</h3>
        <p><strong>Problema General</strong> ‚Üí <strong>Soluci√≥n en C#</strong> ‚Üí <strong>Soluci√≥n en Python</strong></p>
        <p style="margin-top:10px">Cada implementaci√≥n est√° completamente comentada para facilitar tu aprendizaje.</p>
      </div>
      <button class="btn" onclick="showSection('conceptos')">Continuar ‚Üí Conceptos</button>
    </section>

    <!-- CONCEPTOS -->
    <section id="conceptos" class="section">
      <h2>üß© Conceptos Clave</h2>
      <div class="grid">
        <div class="activity">
          <h4>Definiciones Fundamentales</h4>
          <ul>
            <li><strong>V√©rtices (nodos):</strong> entidades del sistema (intersecciones, bodegas, usuarios).</li>
            <li><strong>Aristas:</strong> conexiones entre v√©rtices (calles, enlaces). Pueden ser dirigidas o no dirigidas.</li>
            <li><strong>Peso:</strong> costo, distancia o tiempo asociado a una arista.</li>
            <li><strong>Grado de salida:</strong> n√∫mero de aristas que salen de un v√©rtice (cuenta multiaristas).</li>
            <li><strong>Grado de entrada:</strong> n√∫mero de aristas que llegan a un v√©rtice (cuenta multiaristas).</li>
          </ul>
        </div>
        <div class="activity">
          <h4>Tipos de Grafos</h4>
          <ul>
            <li><strong>No dirigido:</strong> las aristas no tienen direcci√≥n (carretera bidireccional).</li>
            <li><strong>Dirigido:</strong> las aristas tienen direcci√≥n (calle de un solo sentido).</li>
            <li><strong>Ponderado:</strong> las aristas tienen pesos (distancias).</li>
            <li><strong>No ponderado:</strong> las aristas no tienen pesos (solo conexi√≥n s√≠/no).</li>
            <li><strong>Disperso (sparse):</strong> pocas aristas en relaci√≥n a v√©rtices (m ‚â™ n¬≤).</li>
            <li><strong>Denso (dense):</strong> muchas aristas (m ‚âà n¬≤).</li>
            <li><strong>Multigrafo:</strong> permite m√∫ltiples aristas entre el mismo par (u,v) con diferentes pesos.</li>
          </ul>
        </div>
      </div>
      
      <div class="challenge">
        <h3>üéØ Enfoque de Este Documento: Multigrafo Dirigido Ponderado</h3>
        <p>Trabajaremos con un <strong>multigrafo dirigido ponderado</strong>, que combina:</p>
        <ul style="margin-top:10px">
          <li>‚úÖ <strong>Dirigido:</strong> Aristas con direcci√≥n espec√≠fica (A‚ÜíB ‚â† B‚ÜíA)</li>
          <li>‚úÖ <strong>Ponderado:</strong> Cada arista tiene un peso (distancia en km)</li>
          <li>‚úÖ <strong>Multigrafo:</strong> Permite m√∫ltiples aristas (u,v) con diferentes pesos</li>
          <li>‚úÖ <strong>Mixto:</strong> Combina aristas dirigidas y bidireccionales (implementadas como pares dirigidos)</li>
        </ul>
        <p style="margin-top:10px"><strong>Ejemplo del mundo real:</strong> Red de transporte urbano con autopistas y carreteras locales entre las mismas zonas.</p>
      </div>
      
      <p class="note"><strong>üí° Nota:</strong> La elecci√≥n de representaci√≥n afecta directamente la complejidad de operaciones. En multigrafos, operaciones como <code>HasEdge(u,v)</code> retornan <em>true</em> si existe CUALQUIER arista, mientras que <code>HasEdgeWithWeight(u,v,w)</code> busca una arista espec√≠fica.</p>
      <button class="btn" onclick="showSection('representaciones')">Ir a Representaciones ‚Üí</button>
    </section>

    <!-- REPRESENTACIONES -->
    <section id="representaciones" class="section">
      <h2>üó∫Ô∏è Representaciones: Matriz vs Lista</h2>
      <div class="grid">
        <div class="activity">
          <h4>Matriz de Adyacencia</h4>
          <ul>
            <li>Arreglo bidimensional n√ón donde <code>mat[i][j]</code> indica si existe arista i‚Üíj.</li>
            <li><strong>Memoria:</strong> O(n¬≤) - siempre usa espacio cuadr√°tico.</li>
            <li><strong>Consulta de arista:</strong> O(1) - acceso directo.</li>
            <li><strong>Ideal para:</strong> grafos densos o cuando necesitas consultas r√°pidas de existencia.</li>
            <li><strong>Problema:</strong> desperdicia memoria en grafos dispersos.</li>
          </ul>
        </div>
        <div class="activity">
          <h4>Lista de Adyacencia</h4>
          <ul>
            <li>Arreglo/diccionario donde cada v√©rtice guarda una lista de sus vecinos.</li>
            <li><strong>Memoria:</strong> O(n + m) - proporcional a v√©rtices y aristas.</li>
            <li><strong>Consulta de arista:</strong> O(grado(u)) - debe recorrer lista de vecinos.</li>
            <li><strong>Ideal para:</strong> grafos dispersos o cuando recorres vecinos frecuentemente.</li>
            <li><strong>Ventaja:</strong> eficiente en memoria para grafos reales (t√≠picamente dispersos).</li>
          </ul>
        </div>
      </div>

      <table class="comparison-table">
        <thead><tr><th>Operaci√≥n</th><th>Matriz</th><th>Lista</th></tr></thead>
        <tbody>
          <tr><td>Memoria (grafo disperso)</td><td>‚ùå O(n¬≤)</td><td>‚úÖ O(n+m)</td></tr>
          <tr><td>¬øExiste arista (u,v)?</td><td>‚úÖ O(1)</td><td>O(grado(u))</td></tr>
          <tr><td>Agregar arista (sin validar)</td><td>‚úÖ O(1)</td><td>‚úÖ O(1)</td></tr>
          <tr><td>Agregar arista (validando duplicados exactos)</td><td>‚úÖ O(1)</td><td>O(grado(u))</td></tr>
          <tr><td>Eliminar arista</td><td>‚úÖ O(1)</td><td>O(grado(u))</td></tr>
          <tr><td>Eliminar arista espec√≠fica (por peso)</td><td>‚úÖ O(1)</td><td>O(grado(u))</td></tr>
          <tr><td>Recorrer vecinos de u</td><td>O(n)</td><td>‚úÖ O(grado(u))</td></tr>
          <tr><td>Obtener todos los pesos u‚Üív</td><td>O(1)</td><td>‚úÖ O(grado(u))</td></tr>
          <tr><td>Soporte multiaristas</td><td>Complejo (requiere lista de pesos por celda)</td><td>‚úÖ Natural (lista de tuplas)</td></tr>
        </tbody>
      </table>

      <div class="challenge">
        <h3>¬øCu√°ndo usar cada una?</h3>
        <p><strong>Lista de Adyacencia:</strong> Cuando m ‚â™ n¬≤ (grafos dispersos como redes sociales, mapas urbanos).</p>
        <p><strong>Matriz de Adyacencia:</strong> Cuando m ‚âà n¬≤ (grafos densos) o necesitas consultas O(1) constantes.</p>
      </div>

      <button class="btn" onclick="showSection('problema')">Ver el Problema ‚Üí</button>
    </section>

    <!-- PROBLEMA GENERAL -->
    <section id="problema" class="section">
      <h2>üéØ Problema General: Mapa de Ciudad con Zonas Importantes</h2>
      
      <div class="challenge">
        <h3>Contexto del Problema</h3>
        <p>Una ciudad necesita modelar su red de transporte urbano. Hay 8 zonas importantes conectadas por calles. Algunas calles son bidireccionales (dos carriles) y otras de un solo sentido (restricci√≥n vehicular). Cada conexi√≥n tiene una distancia en kil√≥metros.</p>
      </div>

      <div class="activity">
        <h4>V√©rtices (Intersecciones/Zonas)</h4>
        <table class="comparison-table" style="font-size:0.9em">
          <thead><tr><th>ID</th><th>Descripci√≥n</th></tr></thead>
          <tbody>
            <tr><td><strong>A</strong></td><td>Centro Comercial</td></tr>
            <tr><td><strong>B</strong></td><td>Zona Norte</td></tr>
            <tr><td><strong>C</strong></td><td>Zona Sur</td></tr>
            <tr><td><strong>D</strong></td><td>Este Industrial</td></tr>
            <tr><td><strong>E</strong></td><td>Oeste Residencial</td></tr>
            <tr><td><strong>F</strong></td><td>Zona Industrial</td></tr>
            <tr><td><strong>G</strong></td><td>Hospital</td></tr>
            <tr><td><strong>H</strong></td><td>Estadio</td></tr>
          </tbody>
        </table>
      </div>

      <div class="activity">
        <h4>Aristas (Calles) - No Dirigidas (Bidireccionales)</h4>
        <ul style="column-count:2">
          <li>A ‚Üî B: 2.0 km</li>
          <li>A ‚Üî C: 3.0 km</li>
          <li>B ‚Üî D: 1.0 km</li>
          <li>C ‚Üî E: 4.0 km</li>
          <li>D ‚Üî F: 5.0 km</li>
          <li>E ‚Üî F: 2.0 km</li>
          <li>G ‚Üî H: 6.0 km</li>
        </ul>
      </div>

      <div class="activity">
        <h4>Aristas (Calles) - Dirigidas (Un solo sentido)</h4>
        <ul style="column-count:2">
          <li>A ‚Üí G: 1.0 km (al hospital)</li>
          <li>B ‚Üí H: 3.0 km (al estadio)</li>
          <li>C ‚Üí D: 2.0 km</li>
          <li>F ‚Üí E: 4.0 km</li>
          <li>H ‚Üí A: 5.0 km (vuelta al centro)</li>
        </ul>
      </div>

      <div class="error-box">
        <h4>‚ö†Ô∏è Problema Educativo Clave: La Conexi√≥n E-F (Multigrafo)</h4>
        <p><strong>Situaci√≥n:</strong> Observa que existen DOS aristas diferentes entre F y E:</p>
        <ul>
          <li>E ‚Üî F: 2.0 km (bidireccional - se implementa como E‚ÜíF y F‚ÜíE)</li>
          <li>F ‚Üí E: 4.0 km (dirigida adicional - ruta alterna)</li>
        </ul>
        <p><strong>Resultado:</strong> Desde F hacia E existen 2 rutas con diferentes costos:</p>
        <ul>
          <li>F‚ÜíE: 2.0 km (de la bidireccional)</li>
          <li>F‚ÜíE: 4.0 km (dirigida adicional)</li>
        </ul>
        <p><strong>Concepto Te√≥rico: Multigrafo Ponderado</strong></p>
        <p>Un <strong>multigrafo</strong> permite m√∫ltiples aristas entre el mismo par ordenado de v√©rtices (u,v). En este caso, tenemos dos aristas F‚ÜíE con pesos diferentes (2.0 y 4.0 km).</p>
        
        <p><strong>¬øPor qu√© es importante?</strong></p>
        <ul>
          <li><strong>Realismo:</strong> Redes de transporte reales tienen rutas paralelas (autopista vs carretera local)</li>
          <li><strong>Representaci√≥n:</strong> Cada arista tiene diferente costo/velocidad/capacidad</li>
          <li><strong>Algoritmos:</strong> Caminos m√°s cortos deben considerar todas las opciones</li>
        </ul>
        
        <p><strong>Implementaci√≥n Correcta:</strong></p>
        <p>Para soportar multigrafos, la verificaci√≥n de duplicados debe comparar <strong>(destino, peso)</strong> en lugar de solo destino:</p>
        <pre style="font-size:0.85em">‚úÖ Correcto: if not any((neighbor, w) == (v, weight) for neighbor, w in adj[u])
‚ùå Incorrecto: if not any(neighbor == v for neighbor, w in adj[u])</pre>
        
        <p><strong>Implicaciones en Grados:</strong></p>
        <ul>
          <li>OutDegree(F) = 3 (incluye D, E con 2.0 km, E con 4.0 km)</li>
          <li>InDegree(E) = 3 (incluye C, F con 2.0 km, F con 4.0 km)</li>
          <li>Cada arista cuenta por separado aunque tengan mismo origen/destino</li>
        </ul>
      </div>

      <h3>Preguntas que el Sistema Debe Responder</h3>
      <div class="note">
<strong>Consultas b√°sicas:</strong>
1. ¬øExiste ruta directa de E a F? (S√≠, bidireccional 2.0 km)
2. ¬øExiste ruta directa de F a E? (S√≠, DOBLE: bidireccional 2.0 km O dirigida 4.0 km)
3. ¬øCu√°ntas rutas salen del Centro Comercial (A)?
4. ¬øCu√°l es el grado de entrada del Hospital (G)?
5. ¬øQu√© zonas son accesibles desde la Zona Norte (B)?

<strong>Complejidad del grafo mixto:</strong>
Este problema introduce grafos con aristas dirigidas Y no dirigidas simult√°neamente, 
un caso com√∫n en redes de transporte urbano reales.
      </div>

      <div class="error-box">
        <h4>‚ö†Ô∏è Errores Comunes a Evitar</h4>
        <ul>
          <li><strong>‚ùå ERROR CR√çTICO: Verificar duplicados solo por destino</strong> en lugar de (destino, peso) - bloquea multiaristas v√°lidas</li>
          <li><strong>Permitir aristas duplicadas exactas</strong> (mismo u, v, peso) sin verificaci√≥n</li>
          <li><strong>No validar</strong> que los v√©rtices existan antes de operar</li>
          <li><strong>Olvidar actualizar ambas direcciones</strong> en aristas bidireccionales</li>
          <li><strong>Confundir</strong> grado de entrada y salida en grafos dirigidos</li>
          <li><strong>No contar multiaristas</strong> por separado al calcular grados</li>
          <li><strong>Asumir que HasEdge retorna peso</strong> cuando solo indica existencia</li>
        </ul>
      </div>

      <button class="btn" onclick="showSection('cs')">Ver Soluci√≥n en C# ‚Üí</button>
    </section>

    <!-- IMPLEMENTACI√ìN C# -->
    <section id="cs" class="section">
      <h2>üíª Soluci√≥n Completa en C#</h2>
      
      <h3>Clase Grafo con Lista de Adyacencia</h3>
      <div class="code-container">
        <div class="code-header"><span>C# ‚Ä¢ Grafo gen√©rico dirigido ponderado</span><span>Lista de adyacencia</span></div>
        <div class="code-content"><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Collections.Generic;
<span class="keyword">using</span> System.Linq;

<span class="comment">/// &lt;summary&gt;
/// Grafo gen√©rico dirigido con pesos.
/// Usa lista de adyacencia para eficiencia en memoria.
/// &lt;/summary&gt;</span>
<span class="keyword">public</span> <span class="keyword">class</span> Graph&lt;T&gt; {
    <span class="comment">// Diccionario: cada v√©rtice apunta a su lista de (vecino, peso)</span>
    <span class="keyword">private</span> <span class="keyword">readonly</span> Dictionary&lt;T, List&lt;(T to, <span class="keyword">double</span> weight)&gt;&gt; adj = <span class="keyword">new</span>();
    
    <span class="comment">// Flag para indicar si el grafo es dirigido o no</span>
    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">bool</span> isDirected;

    <span class="comment">/// &lt;summary&gt;
    /// Constructor del grafo
    /// &lt;/summary&gt;
    /// &lt;param name="directed"&gt;true para grafo dirigido, false para no dirigido&lt;/param&gt;</span>
    <span class="keyword">public</span> Graph(<span class="keyword">bool</span> directed = <span class="keyword">true</span>) {
        isDirected = directed;
    }

    <span class="comment">/// &lt;summary&gt;
    /// Agrega un v√©rtice al grafo si no existe.
    /// Complejidad: O(1) promedio
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> <span class="keyword">void</span> AddVertex(T v) {
        <span class="keyword">if</span> (!adj.ContainsKey(v)) {
            adj[v] = <span class="keyword">new</span> List&lt;(T, <span class="keyword">double</span>)&gt;();
        }
    }

    <span class="comment">/// &lt;summary&gt;
    /// Agrega una arista al grafo.
    /// SOPORTA MULTIARISTAS: Permite m√∫ltiples aristas entre (u,v) con diferentes pesos.
    /// Previene solo aristas ID√âNTICAS (mismo destino Y mismo peso).
    /// Complejidad: O(grado(u)) por la verificaci√≥n de duplicados exactos
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> <span class="keyword">void</span> AddEdge(T u, T v, <span class="keyword">double</span> weight = <span class="number">1.0</span>) {
        <span class="comment">// Asegurar que ambos v√©rtices existan</span>
        AddVertex(u);
        AddVertex(v);
        
        <span class="comment">// CRUCIAL: Verificar duplicados por (destino, peso)</span>
        <span class="comment">// Esto permite F‚ÜíE (2.0) y F‚ÜíE (4.0) coexistir (multigrafo)</span>
        <span class="comment">// pero previene F‚ÜíE (2.0) duplicado</span>
        <span class="keyword">if</span> (!adj[u].Exists(e =&gt; EqualityComparer&lt;T&gt;.Default.Equals(e.to, v) 
                              && Math.Abs(e.weight - weight) &lt; <span class="number">0.0001</span>)) {
            adj[u].Add((v, weight));
        }
        
        <span class="comment">// Si el grafo NO es dirigido, agregar arista inversa</span>
        <span class="keyword">if</span> (!isDirected) {
            <span class="keyword">if</span> (!adj[v].Exists(e =&gt; EqualityComparer&lt;T&gt;.Default.Equals(e.to, u) 
                                  && Math.Abs(e.weight - weight) &lt; <span class="number">0.0001</span>)) {
                adj[v].Add((u, weight));
            }
        }
    }

    <span class="comment">/// &lt;summary&gt;
    /// Verifica si existe AL MENOS UNA arista entre u y v.
    /// En multigrafos, retorna true si hay cualquier arista u‚Üív (sin importar el peso).
    /// Complejidad: O(grado(u))
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> <span class="keyword">bool</span> HasEdge(T u, T v) {
        <span class="keyword">if</span> (!adj.ContainsKey(u)) {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        
        <span class="comment">// Buscar cualquier arista al destino v</span>
        <span class="keyword">foreach</span> (<span class="keyword">var</span> (neighbor, _) <span class="keyword">in</span> adj[u]) {
            <span class="keyword">if</span> (EqualityComparer&lt;T&gt;.Default.Equals(neighbor, v)) {
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="comment">/// &lt;summary&gt;
    /// Verifica si existe una arista espec√≠fica entre u y v con el peso exacto.
    /// √ötil para multigrafos donde pueden existir m√∫ltiples aristas u‚Üív.
    /// Complejidad: O(grado(u))
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> <span class="keyword">bool</span> HasEdgeWithWeight(T u, T v, <span class="keyword">double</span> weight) {
        <span class="keyword">if</span> (!adj.ContainsKey(u)) {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        
        <span class="comment">// Buscar arista espec√≠fica con el peso exacto</span>
        <span class="keyword">foreach</span> (<span class="keyword">var</span> (neighbor, w) <span class="keyword">in</span> adj[u]) {
            <span class="keyword">if</span> (EqualityComparer&lt;T&gt;.Default.Equals(neighbor, v) 
                && Math.Abs(w - weight) &lt; <span class="number">0.0001</span>) {
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="comment">/// &lt;summary&gt;
    /// Obtiene todos los vecinos de un v√©rtice.
    /// Complejidad: O(1)
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> IEnumerable&lt;(T to, <span class="keyword">double</span> weight)&gt; Neighbors(T u) {
        <span class="keyword">if</span> (!adj.ContainsKey(u)) {
            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException($<span class="string">"V√©rtice {u} no existe en el grafo"</span>);
        }
        <span class="keyword">return</span> adj[u];
    }

    <span class="comment">/// &lt;summary&gt;
    /// Calcula el grado de salida (n√∫mero de aristas salientes).
    /// Complejidad: O(1)
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> <span class="keyword">int</span> OutDegree(T u) {
        <span class="keyword">return</span> adj.ContainsKey(u) ? adj[u].Count : <span class="number">0</span>;
    }

    <span class="comment">/// &lt;summary&gt;
    /// Calcula el grado de entrada (n√∫mero de aristas entrantes).
    /// IMPORTANTE: Necesario para grafos dirigidos.
    /// Complejidad: O(n + m) donde n=v√©rtices, m=aristas
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> <span class="keyword">int</span> InDegree(T v) {
        <span class="keyword">int</span> count = <span class="number">0</span>;
        <span class="comment">// Revisar todos los v√©rtices</span>
        <span class="keyword">foreach</span> (<span class="keyword">var</span> u <span class="keyword">in</span> adj.Keys) {
            <span class="comment">// Contar cu√°ntas veces aparece v en las listas de vecinos</span>
            count += adj[u].Count(e =&gt; EqualityComparer&lt;T&gt;.Default.Equals(e.to, v));
        }
        <span class="keyword">return</span> count;
    }

    <span class="comment">/// &lt;summary&gt;
    /// Elimina TODAS las aristas de u a v (todas las multiaristas si existen).
    /// Complejidad: O(grado(u)) + O(grado(v)) si no es dirigido
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> <span class="keyword">int</span> RemoveEdge(T u, T v) {
        <span class="keyword">int</span> removed = <span class="number">0</span>;
        
        <span class="comment">// Eliminar todas las aristas u ‚Üí v</span>
        <span class="keyword">if</span> (adj.ContainsKey(u)) {
            removed = adj[u].RemoveAll(e =&gt; EqualityComparer&lt;T&gt;.Default.Equals(e.to, v));
        }
        
        <span class="comment">// Si no es dirigido, eliminar tambi√©n todas v ‚Üí u</span>
        <span class="keyword">if</span> (!isDirected && adj.ContainsKey(v)) {
            adj[v].RemoveAll(e =&gt; EqualityComparer&lt;T&gt;.Default.Equals(e.to, u));
        }
        
        <span class="keyword">return</span> removed;
    }

    <span class="comment">/// &lt;summary&gt;
    /// Elimina UNA arista espec√≠fica de u a v con el peso exacto.
    /// En multigrafos, solo elimina la primera coincidencia.
    /// Complejidad: O(grado(u)) + O(grado(v)) si no es dirigido
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> <span class="keyword">bool</span> RemoveEdgeWithWeight(T u, T v, <span class="keyword">double</span> weight) {
        <span class="keyword">bool</span> removed = <span class="keyword">false</span>;
        
        <span class="comment">// Eliminar primera arista u ‚Üí v con peso espec√≠fico</span>
        <span class="keyword">if</span> (adj.ContainsKey(u)) {
            <span class="keyword">int</span> index = adj[u].FindIndex(e =&gt; 
                EqualityComparer&lt;T&gt;.Default.Equals(e.to, v) 
                && Math.Abs(e.weight - weight) &lt; <span class="number">0.0001</span>);
            
            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) {
                adj[u].RemoveAt(index);
                removed = <span class="keyword">true</span>;
            }
        }
        
        <span class="comment">// Si no es dirigido, eliminar tambi√©n v ‚Üí u con mismo peso</span>
        <span class="keyword">if</span> (!isDirected && adj.ContainsKey(v)) {
            <span class="keyword">int</span> index = adj[v].FindIndex(e =&gt; 
                EqualityComparer&lt;T&gt;.Default.Equals(e.to, u) 
                && Math.Abs(e.weight - weight) &lt; <span class="number">0.0001</span>);
            
            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) {
                adj[v].RemoveAt(index);
            }
        }
        
        <span class="keyword">return</span> removed;
    }

    <span class="comment">/// &lt;summary&gt;
    /// Elimina un v√©rtice y todas sus aristas asociadas.
    /// Complejidad: O(n * m) en el peor caso
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> <span class="keyword">bool</span> RemoveVertex(T v) {
        <span class="keyword">if</span> (!adj.ContainsKey(v)) {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        
        <span class="comment">// Eliminar todas las aristas que apuntan a v</span>
        <span class="keyword">foreach</span> (<span class="keyword">var</span> u <span class="keyword">in</span> adj.Keys) {
            adj[u].RemoveAll(e =&gt; EqualityComparer&lt;T&gt;.Default.Equals(e.to, v));
        }
        
        <span class="comment">// Eliminar el v√©rtice en s√≠</span>
        adj.Remove(v);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="comment">/// &lt;summary&gt;
    /// Obtiene todos los v√©rtices del grafo.
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> IEnumerable&lt;T&gt; Vertices() =&gt; adj.Keys;

    <span class="comment">/// &lt;summary&gt;
    /// Cuenta el n√∫mero total de v√©rtices.
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> <span class="keyword">int</span> VertexCount() =&gt; adj.Count;

    <span class="comment">/// &lt;summary&gt;
    /// Cuenta el n√∫mero total de aristas (incluyendo multiaristas).
    /// En multigrafos, cada arista u‚Üív con diferente peso cuenta por separado.
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> <span class="keyword">int</span> EdgeCount() {
        <span class="keyword">int</span> count = adj.Values.Sum(list =&gt; list.Count);
        <span class="comment">// Si no es dirigido, cada arista se cuenta dos veces</span>
        <span class="keyword">return</span> isDirected ? count : count / <span class="number">2</span>;
    }

    <span class="comment">/// &lt;summary&gt;
    /// Obtiene todas las aristas entre dos v√©rtices (√∫til para multigrafos).
    /// Retorna lista de pesos de todas las aristas u‚Üív.
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> List&lt;<span class="keyword">double</span>&gt; GetEdgeWeights(T u, T v) {
        <span class="keyword">if</span> (!adj.ContainsKey(u)) {
            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;<span class="keyword">double</span>&gt;();
        }
        
        <span class="keyword">return</span> adj[u]
            .Where(e =&gt; EqualityComparer&lt;T&gt;.Default.Equals(e.to, v))
            .Select(e =&gt; e.weight)
            .ToList();
    }

    <span class="comment">/// &lt;summary&gt;
    /// Imprime el grafo de forma legible.
    /// &lt;/summary&gt;</span>
    <span class="keyword">public</span> <span class="keyword">void</span> Print() {
        Console.WriteLine($<span class="string">"Grafo {(isDirected ? "</span>dirigido<span class="string">" : "</span>no dirigido<span class="string">")} con {VertexCount()} v√©rtices y {EdgeCount()} aristas:"</span>);
        <span class="keyword">foreach</span> (<span class="keyword">var</span> u <span class="keyword">in</span> adj.Keys) {
            Console.Write($<span class="string">"{u} ‚Üí "</span>);
            <span class="keyword">foreach</span> (<span class="keyword">var</span> (v, w) <span class="keyword">in</span> adj[u]) {
                Console.Write($<span class="string">"({v}, {w:F1}) "</span>);
            }
            Console.WriteLine();
        }
    }
}</div>
      </div>

      <h3>Ejemplo de Uso: Mapa de Ciudad</h3>
      <div class="code-container">
        <div class="code-header"><span>Programa Principal</span></div>
        <div class="code-content"><span class="keyword">class</span> Program {
    <span class="keyword">static</span> <span class="keyword">void</span> Main() {
        Console.WriteLine(<span class="string">"=== MAPA DE CIUDAD - Red de Transporte ===\n"</span>);
        
        <span class="comment">// Crear grafo MIXTO (tendr√° aristas dirigidas y no dirigidas)</span>
        <span class="comment">// Para simplicidad, usamos un grafo dirigido y agregamos aristas en ambas direcciones</span>
        <span class="comment">// cuando la calle es bidireccional</span>
        <span class="keyword">var</span> ciudad = <span class="keyword">new</span> Graph&lt;<span class="keyword">string</span>&gt;(directed: <span class="keyword">true</span>);
        
        <span class="comment">// === ARISTAS NO DIRIGIDAS (bidireccionales) ===</span>
        <span class="comment">// Agregamos en ambas direcciones manualmente</span>
        
        <span class="comment">// A ‚Üî B: 2.0 km</span>
        ciudad.AddEdge(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="number">2.0</span>);
        ciudad.AddEdge(<span class="string">"B"</span>, <span class="string">"A"</span>, <span class="number">2.0</span>);
        
        <span class="comment">// A ‚Üî C: 3.0 km</span>
        ciudad.AddEdge(<span class="string">"A"</span>, <span class="string">"C"</span>, <span class="number">3.0</span>);
        ciudad.AddEdge(<span class="string">"C"</span>, <span class="string">"A"</span>, <span class="number">3.0</span>);
        
        <span class="comment">// B ‚Üî D: 1.0 km</span>
        ciudad.AddEdge(<span class="string">"B"</span>, <span class="string">"D"</span>, <span class="number">1.0</span>);
        ciudad.AddEdge(<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="number">1.0</span>);
        
        <span class="comment">// C ‚Üî E: 4.0 km</span>
        ciudad.AddEdge(<span class="string">"C"</span>, <span class="string">"E"</span>, <span class="number">4.0</span>);
        ciudad.AddEdge(<span class="string">"E"</span>, <span class="string">"C"</span>, <span class="number">4.0</span>);
        
        <span class="comment">// D ‚Üî F: 5.0 km</span>
        ciudad.AddEdge(<span class="string">"D"</span>, <span class="string">"F"</span>, <span class="number">5.0</span>);
        ciudad.AddEdge(<span class="string">"F"</span>, <span class="string">"D"</span>, <span class="number">5.0</span>);
        
        <span class="comment">// E ‚Üî F: 2.0 km (IMPORTANTE: ruta bidireccional corta)</span>
        ciudad.AddEdge(<span class="string">"E"</span>, <span class="string">"F"</span>, <span class="number">2.0</span>);
        ciudad.AddEdge(<span class="string">"F"</span>, <span class="string">"E"</span>, <span class="number">2.0</span>);
        
        <span class="comment">// G ‚Üî H: 6.0 km</span>
        ciudad.AddEdge(<span class="string">"G"</span>, <span class="string">"H"</span>, <span class="number">6.0</span>);
        ciudad.AddEdge(<span class="string">"H"</span>, <span class="string">"G"</span>, <span class="number">6.0</span>);
        
        <span class="comment">// === ARISTAS DIRIGIDAS (un solo sentido) ===</span>
        ciudad.AddEdge(<span class="string">"A"</span>, <span class="string">"G"</span>, <span class="number">1.0</span>);  <span class="comment">// al hospital</span>
        ciudad.AddEdge(<span class="string">"B"</span>, <span class="string">"H"</span>, <span class="number">3.0</span>);  <span class="comment">// al estadio</span>
        ciudad.AddEdge(<span class="string">"C"</span>, <span class="string">"D"</span>, <span class="number">2.0</span>);
        ciudad.AddEdge(<span class="string">"F"</span>, <span class="string">"E"</span>, <span class="number">4.0</span>);  <span class="comment">// RUTA ALTERNA m√°s larga</span>
        ciudad.AddEdge(<span class="string">"H"</span>, <span class="string">"A"</span>, <span class="number">5.0</span>);  <span class="comment">// vuelta al centro</span>
        
        <span class="comment">// Imprimir el grafo completo</span>
        ciudad.Print();
        
        <span class="comment">// === AN√ÅLISIS DEL PROBLEMA E-F ===</span>
        Console.WriteLine(<span class="string">"\n=== AN√ÅLISIS: Conexi√≥n E-F (Multigrafo) ===\n"</span>);
        Console.WriteLine(<span class="string">"Observa que hay M√öLTIPLES rutas entre E y F:"</span>);
        Console.WriteLine($<span class="string">"  E‚ÜíF existe? {ciudad.HasEdge("</span>E<span class="string">", "</span>F<span class="string">")} (ruta bidireccional corta: 2.0 km)"</span>);
        Console.WriteLine($<span class="string">"  F‚ÜíE existe? {ciudad.HasEdge("</span>F<span class="string">", "</span>E<span class="string">")} (M√öLTIPLES rutas disponibles)"</span>);
        
        <span class="comment">// Obtener todas las rutas F‚ÜíE</span>
        <span class="keyword">var</span> rutasFE = ciudad.GetEdgeWeights(<span class="string">"F"</span>, <span class="string">"E"</span>);
        Console.WriteLine($<span class="string">"\nRutas disponibles F‚ÜíE: {rutasFE.Count}"</span>);
        <span class="keyword">foreach</span> (<span class="keyword">var</span> peso <span class="keyword">in</span> rutasFE) {
            Console.WriteLine($<span class="string">"  ‚Ä¢ Ruta con distancia: {peso} km"</span>);
        }
        
        Console.WriteLine(<span class="string">"\nüìö Concepto de MULTIGRAFO:"</span>);
        Console.WriteLine(<span class="string">"   Permite m√∫ltiples aristas entre el mismo par de v√©rtices."</span>);
        Console.WriteLine(<span class="string">"   Interpretaci√≥n pr√°ctica:"</span>);
        Console.WriteLine(<span class="string">"   - Ruta 1 (2.0 km): Carretera local bidireccional"</span>);
        Console.WriteLine(<span class="string">"   - Ruta 2 (4.0 km): Autopista de cuota (m√°s larga, quiz√° m√°s r√°pida)"</span>);
        
        <span class="comment">// Consultas adicionales</span>
        Console.WriteLine(<span class="string">"\n=== CONSULTAS GENERALES ===\n"</span>);
        Console.WriteLine($<span class="string">"¬øPuedo ir de A al Hospital (G)? {ciudad.HasEdge("</span>A<span class="string">", "</span>G<span class="string">")} (dirigida)"</span>);
        Console.WriteLine($<span class="string">"¬øPuedo volver de G a A? {ciudad.HasEdge("</span>G<span class="string">", "</span>A<span class="string">")} (NO hay ruta directa)"</span>);
        
        <span class="comment">// Verificar arista espec√≠fica por peso</span>
        Console.WriteLine($<span class="string">"\n¬øExiste F‚ÜíE con 2.0 km? {ciudad.HasEdgeWithWeight("</span>F<span class="string">", "</span>E<span class="string">", </span><span class="number">2.0</span><span class="string">)}"</span>);
        Console.WriteLine($<span class="string">"¬øExiste F‚ÜíE con 4.0 km? {ciudad.HasEdgeWithWeight("</span>F<span class="string">", "</span>E<span class="string">", </span><span class="number">4.0</span><span class="string">)}"</span>);
        
        <span class="comment">// An√°lisis de grados</span>
        Console.WriteLine(<span class="string">"\n=== AN√ÅLISIS DE GRADOS ===\n"</span>);
        <span class="keyword">var</span> zonas = <span class="keyword">new</span>[] { <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span> };
        <span class="keyword">foreach</span> (<span class="keyword">var</span> zona <span class="keyword">in</span> zonas) {
            Console.WriteLine($<span class="string">"Zona {zona}: salida={ciudad.OutDegree(zona)}, entrada={ciudad.InDegree(zona)}"</span>);
        }
        
        <span class="comment">// Listar destinos desde el Centro Comercial</span>
        Console.WriteLine(<span class="string">"\n=== DESTINOS DESDE CENTRO COMERCIAL (A) ===\n"</span>);
        <span class="keyword">foreach</span> (<span class="keyword">var</span> (destino, dist) <span class="keyword">in</span> ciudad.Neighbors(<span class="string">"A"</span>)) {
            Console.WriteLine($<span class="string">"  ‚Üí Zona {destino} a {dist} km"</span>);
        }
    }
}</div>
      </div>

      <div class="note">
<strong>Salida esperada (parcial):</strong>

=== MAPA DE CIUDAD - Red de Transporte ===

Grafo dirigido con 8 v√©rtices y 19 aristas:
A ‚Üí (B, 2.0) (C, 3.0) (G, 1.0) 
B ‚Üí (A, 2.0) (D, 1.0) (H, 3.0) 
C ‚Üí (A, 3.0) (E, 4.0) (D, 2.0) 
D ‚Üí (B, 1.0) (F, 5.0) 
E ‚Üí (C, 4.0) (F, 2.0) 
F ‚Üí (D, 5.0) (E, 2.0) (E, 4.0)  ‚Üê MULTIARISTAS: Dos rutas F‚ÜíE
G ‚Üí (H, 6.0) 
H ‚Üí (G, 6.0) (A, 5.0) 

=== AN√ÅLISIS: Conexi√≥n E-F (Multigrafo) ===

Observa que hay M√öLTIPLES rutas entre E y F:
  E‚ÜíF existe? True (ruta bidireccional corta: 2.0 km)
  F‚ÜíE existe? True (M√öLTIPLES rutas disponibles)

Rutas disponibles F‚ÜíE: 2
  ‚Ä¢ Ruta con distancia: 2.0 km
  ‚Ä¢ Ruta con distancia: 4.0 km

üìö Concepto de MULTIGRAFO:
   Permite m√∫ltiples aristas entre el mismo par de v√©rtices.
   Interpretaci√≥n pr√°ctica:
   - Ruta 1 (2.0 km): Carretera local bidireccional
   - Ruta 2 (4.0 km): Autopista de cuota (m√°s larga, quiz√° m√°s r√°pida)

=== CONSULTAS GENERALES ===

¬øPuedo ir de A al Hospital (G)? True (dirigida)
¬øPuedo volver de G a A? False (NO hay ruta directa)

¬øExiste F‚ÜíE con 2.0 km? True
¬øExiste F‚ÜíE con 4.0 km? True

=== AN√ÅLISIS DE GRADOS ===

Zona A: salida=3, entrada=2
Zona B: salida=3, entrada=1
Zona C: salida=3, entrada=1
Zona D: salida=2, entrada=2
Zona E: salida=2, entrada=3  ‚Üê NOTA: entrada=3 por las DOS rutas desde F
Zona F: salida=3, entrada=2  ‚Üê NOTA: salida=3 incluye DOS rutas a E (multiaristas)
Zona G: salida=1, entrada=1
Zona H: salida=2, entrada=1
      </div>

      <button class="btn" onclick="showSection('py')">Ver Soluci√≥n en Python ‚Üí</button>
    </section>

    <!-- IMPLEMENTACI√ìN PYTHON -->
    <section id="py" class="section">
      <h2>üêç Soluci√≥n Completa en Python</h2>
      
      <h3>M√≥dulo de Grafo con Carga desde Archivo</h3>
      <div class="code-container">
        <div class="code-header"><span>Python ‚Ä¢ grafo.py</span><span>Lista de adyacencia</span></div>
        <div class="code-content"><span class="comment"># -*- coding: utf-8 -*-</span>
<span class="string">"""
M√≥dulo para trabajar con grafos usando lista de adyacencia.
Soporta carga desde archivos de texto.
"""</span>

<span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict
<span class="keyword">from</span> typing <span class="keyword">import</span> Dict, List, Tuple, Optional

<span class="comment"># Tipo para representar el grafo: Dict[v√©rtice, List[(vecino, peso)]]</span>
Graph = Dict[<span class="keyword">str</span>, List[Tuple[<span class="keyword">str</span>, <span class="keyword">float</span>]]]


<span class="keyword">def</span> create_graph(directed: <span class="keyword">bool</span> = <span class="keyword">True</span>) -&gt; Graph:
    <span class="string">"""
    Crea un nuevo grafo vac√≠o.
    
    Args:
        directed: True para grafo dirigido, False para no dirigido
    
    Returns:
        Diccionario que representa el grafo
    """</span>
    <span class="comment"># defaultdict crea listas vac√≠as autom√°ticamente</span>
    graph = defaultdict(<span class="keyword">list</span>)
    <span class="comment"># Guardamos el tipo de grafo como atributo</span>
    graph._directed = directed
    <span class="keyword">return</span> graph


<span class="keyword">def</span> add_vertex(graph: Graph, v: <span class="keyword">str</span>) -&gt; <span class="keyword">None</span>:
    <span class="string">"""
    Agrega un v√©rtice al grafo si no existe.
    Complejidad: O(1)
    
    Args:
        graph: El grafo donde agregar
        v: Identificador del v√©rtice
    """</span>
    <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> graph:
        graph[v] = []


<span class="keyword">def</span> add_edge(adj, u, v, w=<span class="number">1.0</span>, directed=<span class="keyword">True</span>):
    <span class="string">"""
    Agrega una arista al grafo.
    SOPORTA MULTIARISTAS: Permite m√∫ltiples aristas entre (u,v) con diferentes pesos.
    Previene solo aristas ID√âNTICAS (mismo destino Y mismo peso).
    Complejidad: O(grado(u)) por verificaci√≥n de duplicados exactos
    
    Args:
        adj: El grafo donde agregar
        u: V√©rtice origen
        v: V√©rtice destino
        w: Peso de la arista (default: 1.0)
        directed: Si el grafo es dirigido o no
    """</span>
    <span class="comment"># Asegurar que ambos v√©rtices existan</span>
    add_vertex(adj, u)
    add_vertex(adj, v)
    
    <span class="comment"># CRUCIAL: Verificar duplicados por (destino, peso)</span>
    <span class="comment"># Esto permite F‚ÜíE (2.0) y F‚ÜíE (4.0) coexistir (multigrafo)</span>
    <span class="comment"># pero previene F‚ÜíE (2.0) duplicado</span>
    <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">any</span>((neighbor, weight) == (v, w) <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> adj[u]):
        adj[u].append((v, w))
    
    <span class="comment"># Si el grafo NO es dirigido, agregar arista inversa</span>
    <span class="keyword">if</span> <span class="keyword">not</span> directed:
        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">any</span>((neighbor, weight) == (u, w) <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> adj[v]):
            adj[v].append((u, w))


<span class="keyword">def</span> has_edge(adj, u, v) -&gt; <span class="keyword">bool</span>:
    <span class="string">"""
    Verifica si existe AL MENOS UNA arista entre u y v.
    En multigrafos, retorna True si hay cualquier arista u‚Üív (sin importar el peso).
    Complejidad: O(grado(u))
    
    Args:
        adj: El grafo a consultar
        u: V√©rtice origen
        v: V√©rtice destino
    
    Returns:
        True si existe alguna arista, False en caso contrario
    """</span>
    <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> adj:
        <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="comment"># Buscar cualquier arista al destino v</span>
    <span class="keyword">return</span> <span class="keyword">any</span>(neighbor == v <span class="keyword">for</span> neighbor, w <span class="keyword">in</span> adj[u])


<span class="keyword">def</span> has_edge_with_weight(adj, u, v, weight) -&gt; <span class="keyword">bool</span>:
    <span class="string">"""
    Verifica si existe una arista espec√≠fica entre u y v con el peso exacto.
    √ötil para multigrafos donde pueden existir m√∫ltiples aristas u‚Üív.
    Complejidad: O(grado(u))
    
    Args:
        adj: El grafo a consultar
        u: V√©rtice origen
        v: V√©rtice destino
        weight: Peso exacto a buscar
    
    Returns:
        True si existe la arista con ese peso exacto
    """</span>
    <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> adj:
        <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="comment"># Buscar arista espec√≠fica con el peso exacto (tolerancia para flotantes)</span>
    <span class="keyword">return</span> <span class="keyword">any</span>((neighbor, w) == (v, weight) <span class="keyword">for</span> neighbor, w <span class="keyword">in</span> adj[u])


<span class="keyword">def</span> get_edge_weights(adj, u, v) -&gt; List[<span class="keyword">float</span>]:
    <span class="string">"""
    Obtiene todos los pesos de las aristas entre u y v.
    √ötil para multigrafos para listar todas las rutas alternativas.
    Complejidad: O(grado(u))
    
    Args:
        adj: El grafo a consultar
        u: V√©rtice origen
        v: V√©rtice destino
    
    Returns:
        Lista de pesos de todas las aristas u‚Üív
    """</span>
    <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> adj:
        <span class="keyword">return</span> []
    
    <span class="keyword">return</span> [w <span class="keyword">for</span> neighbor, w <span class="keyword">in</span> adj[u] <span class="keyword">if</span> neighbor == v]


<span class="keyword">def</span> neighbors(graph: Graph, u: <span class="keyword">str</span>) -&gt; List[Tuple[<span class="keyword">str</span>, <span class="keyword">float</span>]]:
    <span class="string">"""
    Obtiene todos los vecinos de un v√©rtice.
    Complejidad: O(1)
    
    Args:
        graph: El grafo a consultar
        u: V√©rtice a consultar
    
    Returns:
        Lista de tuplas (vecino, peso)
    
    Raises:
        KeyError: Si el v√©rtice no existe
    """</span>
    <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> graph:
        <span class="keyword">raise</span> KeyError(<span class="string">f"V√©rtice {u} no existe en el grafo"</span>)
    <span class="keyword">return</span> graph[u]


<span class="keyword">def</span> out_degree(graph: Graph, u: <span class="keyword">str</span>) -&gt; <span class="keyword">int</span>:
    <span class="string">"""
    Calcula el grado de salida de un v√©rtice.
    Complejidad: O(1)
    
    Args:
        graph: El grafo a consultar
        u: V√©rtice a consultar
    
    Returns:
        N√∫mero de aristas salientes
    """</span>
    <span class="keyword">return</span> <span class="keyword">len</span>(graph.get(u, []))


<span class="keyword">def</span> in_degree(graph: Graph, v: <span class="keyword">str</span>) -&gt; <span class="keyword">int</span>:
    <span class="string">"""
    Calcula el grado de entrada de un v√©rtice.
    IMPORTANTE: Necesario para grafos dirigidos.
    Complejidad: O(n + m)
    
    Args:
        graph: El grafo a consultar
        v: V√©rtice a consultar
    
    Returns:
        N√∫mero de aristas entrantes
    """</span>
    count = <span class="number">0</span>
    <span class="comment"># Revisar todos los v√©rtices</span>
    <span class="keyword">for</span> u <span class="keyword">in</span> graph:
        <span class="comment"># Contar cu√°ntas veces aparece v en la lista de vecinos de u</span>
        count += <span class="keyword">sum</span>(<span class="number">1</span> <span class="keyword">for</span> neighbor, w <span class="keyword">in</span> graph[u] <span class="keyword">if</span> neighbor == v)
    <span class="keyword">return</span> count


<span class="keyword">def</span> remove_edge(adj, u, v) -&gt; <span class="keyword">int</span>:
    <span class="string">"""
    Elimina TODAS las aristas de u a v (todas las multiaristas si existen).
    Complejidad: O(grado(u))
    
    Args:
        adj: El grafo a modificar
        u: V√©rtice origen
        v: V√©rtice destino
    
    Returns:
        N√∫mero de aristas eliminadas
    """</span>
    removed = <span class="number">0</span>
    
    <span class="comment"># Contar cu√°ntas se eliminar√°n</span>
    <span class="keyword">if</span> u <span class="keyword">in</span> adj:
        removed = <span class="keyword">sum</span>(<span class="number">1</span> <span class="keyword">for</span> neighbor, w <span class="keyword">in</span> adj[u] <span class="keyword">if</span> neighbor == v)
        <span class="comment"># Eliminar todas las aristas u ‚Üí v</span>
        adj[u] = [(neighbor, w) <span class="keyword">for</span> neighbor, w <span class="keyword">in</span> adj[u] <span class="keyword">if</span> neighbor != v]
    
    <span class="comment"># Si no es dirigido, eliminar tambi√©n todas v ‚Üí u</span>
    <span class="keyword">if</span> <span class="keyword">not</span> adj._directed <span class="keyword">and</span> v <span class="keyword">in</span> adj:
        adj[v] = [(neighbor, w) <span class="keyword">for</span> neighbor, w <span class="keyword">in</span> adj[v] <span class="keyword">if</span> neighbor != u]
    
    <span class="keyword">return</span> removed


<span class="keyword">def</span> remove_edge_with_weight(adj, u, v, weight) -&gt; <span class="keyword">bool</span>:
    <span class="string">"""
    Elimina UNA arista espec√≠fica de u a v con el peso exacto.
    En multigrafos, solo elimina la primera coincidencia.
    Complejidad: O(grado(u))
    
    Args:
        adj: El grafo a modificar
        u: V√©rtice origen
        v: V√©rtice destino
        weight: Peso exacto de la arista a eliminar
    
    Returns:
        True si se elimin√≥, False si no exist√≠a
    """</span>
    <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> adj:
        <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="comment"># Buscar la arista espec√≠fica</span>
    <span class="keyword">for</span> i, (neighbor, w) <span class="keyword">in</span> <span class="keyword">enumerate</span>(adj[u]):
        <span class="keyword">if</span> neighbor == v <span class="keyword">and</span> w == weight:
            <span class="comment"># Eliminar esta arista espec√≠fica</span>
            <span class="keyword">del</span> adj[u][i]
            
            <span class="comment"># Si no es dirigido, eliminar tambi√©n v ‚Üí u con mismo peso</span>
            <span class="keyword">if</span> <span class="keyword">not</span> adj._directed <span class="keyword">and</span> v <span class="keyword">in</span> adj:
                <span class="keyword">for</span> j, (n, w2) <span class="keyword">in</span> <span class="keyword">enumerate</span>(adj[v]):
                    <span class="keyword">if</span> n == u <span class="keyword">and</span> w2 == weight:
                        <span class="keyword">del</span> adj[v][j]
                        <span class="keyword">break</span>
            
            <span class="keyword">return</span> <span class="keyword">True</span>
    
    <span class="keyword">return</span> <span class="keyword">False</span>


<span class="keyword">def</span> load_graph(path: <span class="keyword">str</span>, directed: <span class="keyword">bool</span> = <span class="keyword">True</span>) -&gt; Graph:
    <span class="string">"""
    Carga un grafo desde un archivo de texto.
    
    Formato del archivo:
        # Comentarios (l√≠neas que empiezan con #)
        u v peso
        u v peso
        ...
    
    Complejidad: O(m * grado_promedio) donde m = n√∫mero de aristas
    
    Args:
        path: Ruta al archivo
        directed: True para grafo dirigido, False para no dirigido
    
    Returns:
        Grafo cargado desde el archivo
    
    Raises:
        FileNotFoundError: Si el archivo no existe
        ValueError: Si hay l√≠neas con formato inv√°lido
    """</span>
    graph = create_graph(directed)
    
    <span class="keyword">try</span>:
        <span class="keyword">with</span> <span class="keyword">open</span>(path, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:
            <span class="keyword">for</span> line_num, line <span class="keyword">in</span> <span class="keyword">enumerate</span>(f, <span class="number">1</span>):
                <span class="comment"># Eliminar espacios en blanco al inicio y final</span>
                line = line.strip()
                
                <span class="comment"># Ignorar l√≠neas vac√≠as y comentarios</span>
                <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">or</span> line.startswith(<span class="string">'#'</span>):
                    <span class="keyword">continue</span>
                
                <span class="comment"># Dividir la l√≠nea en partes</span>
                parts = line.split()
                
                <span class="comment"># Validar formato m√≠nimo: u v [peso]</span>
                <span class="keyword">if</span> <span class="keyword">len</span>(parts) &lt; <span class="number">2</span>:
                    <span class="keyword">raise</span> ValueError(<span class="string">f"L√≠nea {line_num}: formato inv√°lido '{line}'"</span>)
                
                <span class="comment"># Extraer v√©rtices</span>
                u, v = parts[<span class="number">0</span>], parts[<span class="number">1</span>]
                
                <span class="comment"># Extraer peso (opcional, default = 1.0)</span>
                <span class="keyword">try</span>:
                    weight = <span class="keyword">float</span>(parts[<span class="number">2</span>]) <span class="keyword">if</span> <span class="keyword">len</span>(parts) &gt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">1.0</span>
                <span class="keyword">except</span> ValueError:
                    <span class="keyword">raise</span> ValueError(<span class="string">f"L√≠nea {line_num}: peso inv√°lido '{parts[2]}'"</span>)
                
                <span class="comment"># Agregar la arista (con prevenci√≥n de duplicados)</span>
                add_edge(graph, u, v, weight)
        
        <span class="keyword">return</span> graph
    
    <span class="keyword">except</span> FileNotFoundError:
        <span class="keyword">raise</span> FileNotFoundError(<span class="string">f"No se encontr√≥ el archivo: {path}"</span>)


<span class="keyword">def</span> print_graph(graph: Graph) -&gt; <span class="keyword">None</span>:
    <span class="string">"""
    Imprime el grafo de forma legible.
    
    Args:
        graph: El grafo a imprimir
    """</span>
    tipo = <span class="string">"dirigido"</span> <span class="keyword">if</span> graph._directed <span class="keyword">else</span> <span class="string">"no dirigido"</span>
    num_vertices = <span class="keyword">len</span>(graph)
    num_aristas = <span class="keyword">sum</span>(<span class="keyword">len</span>(vecinos) <span class="keyword">for</span> vecinos <span class="keyword">in</span> graph.values())
    <span class="keyword">if</span> <span class="keyword">not</span> graph._directed:
        num_aristas //= <span class="number">2</span>  <span class="comment"># Cada arista se cuenta dos veces</span>
    
    <span class="keyword">print</span>(<span class="string">f"Grafo {tipo} con {num_vertices} v√©rtices y {num_aristas} aristas:"</span>)
    
    <span class="keyword">for</span> u <span class="keyword">in</span> <span class="keyword">sorted</span>(graph.keys()):
        vecinos_str = <span class="string">" "</span>.join(<span class="string">f"({v}, {w:.1f})"</span> <span class="keyword">for</span> v, w <span class="keyword">in</span> graph[u])
        <span class="keyword">print</span>(<span class="string">f"{u} ‚Üí {vecinos_str}"</span>)</div>
      </div>

      <h3>Formato del Archivo de Entrada</h3>
      <div class="note">
<strong>Archivo: ciudad.txt</strong>

# Mapa de ciudad - Red de transporte urbano
# Formato: origen destino distancia_km [tipo]
# Tipo: B=bidireccional, D=dirigida

# === CALLES BIDIRECCIONALES ===
# (Se representan agregando la arista en ambas direcciones)

# A ‚Üî B: 2.0 km
A B 2.0
B A 2.0

# A ‚Üî C: 3.0 km  
A C 3.0
C A 3.0

# B ‚Üî D: 1.0 km
B D 1.0
D B 1.0

# C ‚Üî E: 4.0 km
C E 4.0
E C 4.0

# D ‚Üî F: 5.0 km
D F 5.0
F D 5.0

# E ‚Üî F: 2.0 km (ruta corta)
E F 2.0
F E 2.0

# G ‚Üî H: 6.0 km
G H 6.0
H G 6.0

# === CALLES DE UN SOLO SENTIDO ===

A G 1.0
B H 3.0
C D 2.0
F E 4.0
H A 5.0
      </div>

      <h3>Programa Principal de Prueba</h3>
      <div class="code-container">
        <div class="code-header"><span>main.py</span></div>
        <div class="code-content"><span class="comment">#!/usr/bin/env python3</span>
<span class="comment"># -*- coding: utf-8 -*-</span>
<span class="string">"""
Mapa de ciudad - An√°lisis de red de transporte urbano.
Ejemplo educativo sobre grafos mixtos (dirigidos + no dirigidos).
"""</span>

<span class="keyword">from</span> grafo <span class="keyword">import</span> *

<span class="keyword">def</span> main():
    <span class="keyword">print</span>(<span class="string">"="</span> * <span class="number">70</span>)
    <span class="keyword">print</span>(<span class="string">"MAPA DE CIUDAD - Red de Transporte Urbano"</span>)
    <span class="keyword">print</span>(<span class="string">"="</span> * <span class="number">70</span>)
    
    <span class="comment"># Diccionario de descripciones de zonas</span>
    zonas_desc = {
        <span class="string">"A"</span>: <span class="string">"Centro Comercial"</span>,
        <span class="string">"B"</span>: <span class="string">"Zona Norte"</span>,
        <span class="string">"C"</span>: <span class="string">"Zona Sur"</span>,
        <span class="string">"D"</span>: <span class="string">"Este Industrial"</span>,
        <span class="string">"E"</span>: <span class="string">"Oeste Residencial"</span>,
        <span class="string">"F"</span>: <span class="string">"Zona Industrial"</span>,
        <span class="string">"G"</span>: <span class="string">"Hospital"</span>,
        <span class="string">"H"</span>: <span class="string">"Estadio"</span>
    }
    
    <span class="comment"># Cargar grafo desde archivo</span>
    <span class="keyword">try</span>:
        ciudad = load_graph(<span class="string">"ciudad.txt"</span>, directed=<span class="keyword">True</span>)
        <span class="keyword">print</span>(<span class="string">"\n‚úì Grafo cargado exitosamente desde 'ciudad.txt'\n"</span>)
    <span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> e:
        <span class="keyword">print</span>(<span class="string">f"\n‚úó Error: {e}"</span>)
        <span class="keyword">print</span>(<span class="string">"   Aseg√∫rate de tener el archivo 'ciudad.txt' en el directorio actual."</span>)
        <span class="keyword">return</span>
    
    <span class="comment"># Imprimir el grafo completo</span>
    print_graph(ciudad)
    
    <span class="comment"># === AN√ÅLISIS ESPECIAL: Problema E-F ===</span>
    <span class="keyword">print</span>(<span class="string">"\n" + "="</span> * <span class="number">70</span>)
    <span class="keyword">print</span>(<span class="string">"AN√ÅLISIS ESPECIAL: Conexi√≥n E-F (Multigrafo)"</span>)
    <span class="keyword">print</span>(<span class="string">"="</span> * <span class="number">70</span>)
    
    <span class="keyword">print</span>(<span class="string">"\nüîç Observaci√≥n importante:"</span>)
    <span class="keyword">print</span>(<span class="string">"   Hay M√öLTIPLES rutas entre E (Oeste Residencial) y F (Zona Industrial)\n"</span>)
    
    <span class="comment"># Obtener todas las rutas E‚ÜíF</span>
    rutas_e_f = get_edge_weights(ciudad, <span class="string">"E"</span>, <span class="string">"F"</span>)
    <span class="keyword">print</span>(<span class="string">f"Rutas desde E‚ÜíF: {len(rutas_e_f)} ruta(s)"</span>)
    <span class="keyword">for</span> i, peso <span class="keyword">in</span> <span class="keyword">enumerate</span>(rutas_e_f, <span class="number">1</span>):
        <span class="keyword">print</span>(<span class="string">f"  {i}. Distancia: {peso:.1f} km"</span>)
    
    <span class="comment"># Obtener todas las rutas F‚ÜíE</span>
    rutas_f_e = get_edge_weights(ciudad, <span class="string">"F"</span>, <span class="string">"E"</span>)
    <span class="keyword">print</span>(<span class="string">f"\nRutas desde F‚ÜíE: {len(rutas_f_e)} ruta(s)"</span>)
    <span class="keyword">for</span> i, peso <span class="keyword">in</span> <span class="keyword">enumerate</span>(rutas_f_e, <span class="number">1</span>):
        <span class="keyword">print</span>(<span class="string">f"  {i}. Distancia: {peso:.1f} km"</span>)
    
    <span class="keyword">if</span> <span class="keyword">len</span>(rutas_f_e) &gt; <span class="number">1</span>:
        <span class="keyword">print</span>(<span class="string">"\n‚ö†Ô∏è  M√öLTIPLES RUTAS DETECTADAS (Multigrafo):"</span>)
        <span class="keyword">print</span>(<span class="string">"   üìö Concepto: Esto es un MULTIGRAFO ponderado."</span>)
        <span class="keyword">print</span>(<span class="string">"       Permite m√∫ltiples aristas entre el mismo par de v√©rtices."</span>)
        <span class="keyword">print</span>(<span class="string">"\n   üöó Interpretaci√≥n pr√°ctica:"</span>)
        <span class="keyword">print</span>(<span class="string">f"       - Ruta 1 ({rutas_f_e[0]:.1f} km): Carretera local bidireccional"</span>)
        <span class="keyword">print</span>(<span class="string">f"       - Ruta 2 ({rutas_f_e[1]:.1f} km): Autopista de cuota (m√°s larga pero quiz√° m√°s r√°pida)"</span>)
    
    <span class="comment"># === CONSULTAS GENERALES ===</span>
    <span class="keyword">print</span>(<span class="string">"\n" + "="</span> * <span class="number">70</span>)
    <span class="keyword">print</span>(<span class="string">"CONSULTAS DE CONECTIVIDAD"</span>)
    <span class="keyword">print</span>(<span class="string">"="</span> * <span class="number">70</span> + <span class="string">"\n"</span>)
    
    consultas = [
        (<span class="string">"A"</span>, <span class="string">"G"</span>, <span class="string">"¬øPuedo ir del Centro al Hospital?"</span>),
        (<span class="string">"G"</span>, <span class="string">"A"</span>, <span class="string">"¬øPuedo volver del Hospital al Centro?"</span>),
        (<span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"¬øExiste E‚ÜíF?"</span>),
        (<span class="string">"F"</span>, <span class="string">"E"</span>, <span class="string">"¬øExiste F‚ÜíE?"</span>),
        (<span class="string">"B"</span>, <span class="string">"H"</span>, <span class="string">"¬øPuedo ir de Zona Norte al Estadio?"</span>),
        (<span class="string">"H"</span>, <span class="string">"B"</span>, <span class="string">"¬øPuedo volver del Estadio a Zona Norte?"</span>),
    ]
    
    <span class="keyword">for</span> origen, destino, pregunta <span class="keyword">in</span> consultas:
        existe = has_edge(ciudad, origen, destino)
        simbolo = <span class="string">"‚úì"</span> <span class="keyword">if</span> existe <span class="keyword">else</span> <span class="string">"‚úó"</span>
        <span class="keyword">print</span>(<span class="string">f"{simbolo} {pregunta}"</span>)
        <span class="keyword">print</span>(<span class="string">f"   {origen}‚Üí{destino}: {'S√ç' if existe else 'NO'}\n"</span>)
    
    <span class="comment"># Verificar aristas espec√≠ficas por peso</span>
    <span class="keyword">print</span>(<span class="string">"Verificaci√≥n de aristas espec√≠ficas por peso:"</span>)
    <span class="keyword">print</span>(<span class="string">f"  ¬øExiste F‚ÜíE con 2.0 km? {has_edge_with_weight(ciudad, 'F', 'E', 2.0)}"</span>)
    <span class="keyword">print</span>(<span class="string">f"  ¬øExiste F‚ÜíE con 4.0 km? {has_edge_with_weight(ciudad, 'F', 'E', 4.0)}\n"</span>)
    
    <span class="comment"># === AN√ÅLISIS DE GRADOS ===</span>
    <span class="keyword">print</span>(<span class="string">"=" * 70</span>)
    <span class="keyword">print</span>(<span class="string">"AN√ÅLISIS DE GRADOS (Conectividad)"</span>)
    <span class="keyword">print</span>(<span class="string">"=" * 70 + "\n"</span>)
    
    <span class="keyword">for</span> zona <span class="keyword">in</span> <span class="keyword">sorted</span>(ciudad.keys()):
        desc = zonas_desc.get(zona, <span class="string">"Desconocida"</span>)
        out_deg = out_degree(ciudad, zona)
        in_deg = in_degree(ciudad, zona)
        
        <span class="keyword">print</span>(<span class="string">f"Zona {zona} ({desc}):"</span>)
        <span class="keyword">print</span>(<span class="string">f"  ‚îú‚îÄ Grado salida:  {out_deg} (calles que salen)"</span>)
        <span class="keyword">print</span>(<span class="string">f"  ‚îî‚îÄ Grado entrada: {in_deg} (calles que llegan)"</span>)
        
        <span class="keyword">if</span> out_deg == <span class="number">0</span>:
            <span class="keyword">print</span>(<span class="string">f"     ‚ö†Ô∏è  Zona sin salidas!"</span>)
        <span class="keyword">if</span> in_deg == <span class="number">0</span>:
            <span class="keyword">print</span>(<span class="string">f"     ‚ö†Ô∏è  Zona inaccesible!"</span>)
        <span class="keyword">print</span>()
    
    <span class="comment"># === RUTAS DESDE CENTRO COMERCIAL ===</span>
    <span class="keyword">print</span>(<span class="string">"=" * 70</span>)
    <span class="keyword">print</span>(<span class="string">"RUTAS DIRECTAS DESDE CENTRO COMERCIAL (A)"</span>)
    <span class="keyword">print</span>(<span class="string">"=" * 70 + "\n"</span>)
    
    <span class="keyword">try</span>:
        <span class="keyword">for</span> destino, distancia <span class="keyword">in</span> neighbors(ciudad, <span class="string">"A"</span>):
            desc_destino = zonas_desc.get(destino, <span class="string">"Desconocida"</span>)
            <span class="keyword">print</span>(<span class="string">f"  ‚Üí Zona {destino} ({desc_destino}) a {distancia:.1f} km"</span>)
    <span class="keyword">except</span> KeyError:
        <span class="keyword">print</span>(<span class="string">"  ‚úó No se encontr√≥ la zona A"</span>)
    
    <span class="comment"># === PRUEBA DE ELIMINACI√ìN ===</span>
    <span class="keyword">print</span>(<span class="string">"\n" + "=" * 70</span>)
    <span class="keyword">print</span>(<span class="string">"PRUEBA: Cierre temporal de calle por mantenimiento"</span>)
    <span class="keyword">print</span>(<span class="string">"=" * 70 + "\n"</span>)
    
    <span class="keyword">print</span>(<span class="string">"Cerrando calle C‚ÜíD (Zona Sur ‚Üí Este Industrial)..."</span>)
    removed = remove_edge(ciudad, <span class="string">"C"</span>, <span class="string">"D"</span>)
    <span class="keyword">print</span>(<span class="string">f"Resultado: {'‚úì Eliminada' if removed else '‚úó No exist√≠a'}\n"</span>)
    
    <span class="keyword">print</span>(<span class="string">"Estado de la red despu√©s del cierre:"</span>)
    <span class="keyword">print</span>(<span class="string">f"  C‚ÜíD: {'Existe' if has_edge(ciudad, 'C', 'D') else 'CERRADA'}"</span>)
    <span class="keyword">print</span>(<span class="string">f"  D‚ÜíC: {'Existe' if has_edge(ciudad, 'D', 'C') else 'Cerrada'} (bidireccional no afectada)"</span>)
    
    <span class="keyword">print</span>(<span class="string">"\n‚úì An√°lisis completado."</span>)


<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    main()</div>
      </div>

      <div class="note">
<strong>Salida esperada (fragmento clave):</strong>

======================================================================
MAPA DE CIUDAD - Red de Transporte Urbano
======================================================================

‚úì Grafo cargado exitosamente desde 'ciudad.txt'

Grafo dirigido con 8 v√©rtices y 19 aristas:
A ‚Üí (B, 2.0) (C, 3.0) (G, 1.0) 
B ‚Üí (A, 2.0) (D, 1.0) (H, 3.0) 
C ‚Üí (A, 3.0) (E, 4.0) (D, 2.0) 
D ‚Üí (B, 1.0) (F, 5.0) 
E ‚Üí (C, 4.0) (F, 2.0) 
F ‚Üí (D, 5.0) (E, 2.0) (E, 4.0)  ‚Üê MULTIARISTAS: Dos rutas F‚ÜíE
G ‚Üí (H, 6.0) 
H ‚Üí (G, 6.0) (A, 5.0) 

======================================================================
AN√ÅLISIS ESPECIAL: Conexi√≥n E-F (Multigrafo)
======================================================================

üîç Observaci√≥n importante:
   Hay M√öLTIPLES rutas entre E (Oeste Residencial) y F (Zona Industrial)

Rutas desde E‚ÜíF: 1 ruta(s)
  1. Distancia: 2.0 km

Rutas desde F‚ÜíE: 2 ruta(s)
  1. Distancia: 2.0 km
  2. Distancia: 4.0 km

‚ö†Ô∏è  M√öLTIPLES RUTAS DETECTADAS (Multigrafo):
   üìö Concepto: Esto es un MULTIGRAFO ponderado.
       Permite m√∫ltiples aristas entre el mismo par de v√©rtices.

   üöó Interpretaci√≥n pr√°ctica:
       - Ruta 1 (2.0 km): Carretera local bidireccional
       - Ruta 2 (4.0 km): Autopista de cuota (m√°s larga pero quiz√° m√°s r√°pida)

======================================================================
CONSULTAS DE CONECTIVIDAD
======================================================================

‚úì ¬øPuedo ir del Centro al Hospital?
   A‚ÜíG: S√ç

‚úó ¬øPuedo volver del Hospital al Centro?
   G‚ÜíA: NO

‚úì ¬øExiste E‚ÜíF?
   E‚ÜíF: S√ç

‚úì ¬øExiste F‚ÜíE?
   F‚ÜíE: S√ç

Verificaci√≥n de aristas espec√≠ficas por peso:
  ¬øExiste F‚ÜíE con 2.0 km? True
  ¬øExiste F‚ÜíE con 4.0 km? True

======================================================================
AN√ÅLISIS DE GRADOS (Conectividad)
======================================================================

Zona A (Centro Comercial):
  ‚îú‚îÄ Grado salida:  3 (calles que salen)
  ‚îî‚îÄ Grado entrada: 2 (calles que llegan)

Zona E (Oeste Residencial):
  ‚îú‚îÄ Grado salida:  2 (calles que salen)
  ‚îî‚îÄ Grado entrada: 3 (calles que llegan)  ‚Üê DOS rutas desde F

Zona F (Zona Industrial):
  ‚îú‚îÄ Grado salida:  3 (calles que salen)  ‚Üê DOS rutas hacia E
  ‚îî‚îÄ Grado entrada: 2 (calles que llegan)
      </div>

      <button class="btn" onclick="showSection('actividades')">Ir a Actividades ‚Üí</button>
    </section>

    <!-- ACTIVIDADES -->
    <section id="actividades" class="section">
      <h2>üß™ Actividades Pr√°cticas</h2>
      
      <div class="activity">
        <h4>Actividad 1: An√°lisis del Mapa de Ciudad</h4>
        <p><strong>Objetivo:</strong> Comprender el grafo mixto del ejemplo</p>
        <ol>
          <li>Dibuja en papel el grafo completo de la ciudad (v√©rtices A-H).</li>
          <li>Usa <strong>l√≠neas dobles</strong> para aristas bidireccionales y <strong>flechas</strong> para dirigidas.</li>
          <li>Identifica:
            <ul>
              <li>¬øCu√°les zonas est√°n completamente aisladas? (sin conexiones bidireccionales al resto)</li>
              <li>¬øDesde qu√© zona(s) puedes llegar a todas las dem√°s?</li>
              <li>El problema E-F: ¬øcu√°ntas formas hay de ir de F a E? M√°rcalas con diferentes colores.</li>
            </ul>
          </li>
        </ol>
      </div>

      <div class="activity">
        <h4>Actividad 2: Implementaci√≥n en C#</h4>
        <p><strong>Objetivo:</strong> Aplicar la clase Graph al mapa de ciudad</p>
        <ol>
          <li>Crea un proyecto de consola en C#.</li>
          <li>Copia la clase <code>Graph&lt;T&gt;</code> completa.</li>
          <li>Implementa el mapa de ciudad exactamente como se muestra en el ejemplo.</li>
          <li>Agrega las siguientes consultas personalizadas:
            <ul>
              <li>Imprime todas las zonas con grado de entrada = 0 (inaccesibles)</li>
              <li>Imprime todas las zonas con grado de salida = 0 (sin salidas)</li>
              <li>Calcula la distancia total de todas las aristas del grafo</li>
              <li>Encuentra el v√©rtice con mayor grado de salida</li>
            </ul>
          </li>
        </ol>
      </div>

      <div class="activity">
        <h4>Actividad 3: Archivo de Aristas y Python</h4>
        <p><strong>Objetivo:</strong> Cargar el mapa desde archivo y analizarlo</p>
        <ol>
          <li>Crea el archivo <code>ciudad.txt</code> con todas las aristas mostradas en el ejemplo.</li>
          <li>Copia el m√≥dulo <code>grafo.py</code> completo.</li>
          <li>Ejecuta el programa <code>main.py</code> y verifica la salida.</li>
          <li>Modifica el programa para:
            <ul>
              <li>Agregar una funci√≥n que encuentre todas las zonas con m√∫ltiples rutas desde/hacia otra zona</li>
              <li>Calcular el "costo" promedio de las aristas</li>
              <li>Identificar aristas "cr√≠ticas" (si se eliminan, alguna zona queda aislada)</li>
            </ul>
          </li>
        </ol>
      </div>

      <div class="error-box">
        <h4>üéØ Reto Especial: An√°lisis del Problema E-F</h4>
        <p><strong>Desaf√≠o:</strong> Implementa una funci√≥n que detecte autom√°ticamente pares de v√©rtices con m√∫ltiples rutas entre ellos.</p>
        <p><strong>Requerimiento C#:</strong></p>
        <pre class="note">public List&lt;(T, T, int)&gt; FindMultipleRoutes()
// Retorna lista de tuplas: (origen, destino, cantidad_de_rutas)</pre>
        <p><strong>Requerimiento Python:</strong></p>
        <pre class="note">def find_multiple_routes(graph):
    """Retorna dict con pares que tienen m√∫ltiples rutas"""
    # Tu c√≥digo aqu√≠</pre>
        <p><strong>Resultado esperado:</strong> Debe detectar que F‚ÜíE tiene 2 rutas (2.0 km y 4.0 km).</p>
      </div>

      <div class="activity">
        <h4>Actividad 4: Extensiones (Opcional pero Recomendado)</h4>
        <p><strong>Objetivo:</strong> Profundizar en operaciones avanzadas</p>
        <ul>
          <li><strong>Algoritmo de caminos:</strong> Implementa BFS para encontrar si existe camino entre dos zonas (aunque no sea directo).</li>
          <li><strong>An√°lisis de conectividad:</strong> Determina si desde el Centro Comercial (A) se puede llegar a todas las dem√°s zonas.</li>
          <li><strong>Grafo inverso:</strong> Crea una funci√≥n que invierta la direcci√≥n de todas las aristas dirigidas.</li>
          <li><strong>Visualizaci√≥n:</strong> Exporta el grafo a formato DOT de Graphviz para visualizarlo.</li>
          <li><strong>Estad√≠sticas:</strong> Calcula la distribuci√≥n de grados (cu√°ntos v√©rtices tienen grado 0, 1, 2, etc.)</li>
        </ul>
      </div>

      <button class="btn" onclick="showSection('comparacion')">Ver Comparaci√≥n ‚Üí</button>
    </section>

    <!-- COMPARACI√ìN -->
    <section id="comparacion" class="section">
      <h2>‚öñÔ∏è Matriz vs Lista ‚Äì An√°lisis de Trade-offs</h2>
      
      <table class="comparison-table">
        <thead>
          <tr><th>Criterio</th><th>Matriz de Adyacencia</th><th>Lista de Adyacencia</th></tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Memoria</strong></td>
            <td>O(n¬≤) - siempre cuadr√°tico</td>
            <td>‚úÖ O(n + m) - lineal en aristas</td>
          </tr>
          <tr>
            <td><strong>Consulta (u,v)</strong></td>
            <td>‚úÖ O(1) - acceso directo</td>
            <td>O(grado(u)) - b√∫squeda secuencial</td>
          </tr>
          <tr>
            <td><strong>Agregar arista</strong></td>
            <td>‚úÖ O(1)</td>
            <td>O(1) sin validar / O(grado(u)) validando</td>
          </tr>
          <tr>
            <td><strong>Eliminar arista</strong></td>
            <td>‚úÖ O(1)</td>
            <td>O(grado(u))</td>
          </tr>
          <tr>
            <td><strong>Recorrer vecinos</strong></td>
            <td>O(n) - revisar toda la fila</td>
            <td>‚úÖ O(grado(u)) - solo vecinos reales</td>
          </tr>
          <tr>
            <td><strong>Espacio para grafo disperso</strong><br>(m ‚â™ n¬≤)</td>
            <td>‚ùå Desperdicia mucho espacio</td>
            <td>‚úÖ Eficiente</td>
          </tr>
          <tr>
            <td><strong>Espacio para grafo denso</strong><br>(m ‚âà n¬≤)</td>
            <td>‚úÖ Apropiado</td>
            <td>Similar a matriz</td>
          </tr>
          <tr>
            <td><strong>Complejidad implementaci√≥n</strong></td>
            <td>‚úÖ Muy simple</td>
            <td>Media (requiere estructuras din√°micas)</td>
          </tr>
          <tr>
            <td><strong>Soporte para multiaristas</strong></td>
            <td>Complejo (requiere lista de pesos por celda)</td>
            <td>‚úÖ Natural (lista de tuplas (v, peso))</td>
          </tr>
          <tr>
            <td><strong>Casos de uso ideales</strong></td>
            <td>
              ‚Ä¢ Grafos densos<br>
              ‚Ä¢ Consultas frecuentes de existencia<br>
              ‚Ä¢ n peque√±o (< 1000)
            </td>
            <td>
              ‚úÖ ‚Ä¢ Grafos dispersos (t√≠pico en la pr√°ctica)<br>
              ‚Ä¢ Algoritmos de recorrido (BFS, DFS)<br>
              ‚Ä¢ Redes del mundo real<br>
              ‚Ä¢ Multigrafos<br>
              ‚Ä¢ n grande
            </td>
          </tr>
        </tbody>
      </table>

      <div class="challenge">
        <h3>Regla de Oro para la Decisi√≥n</h3>
        <p><strong>Si m ‚â™ n¬≤:</strong> Usa <strong>Lista de Adyacencia</strong> (casi todos los casos reales)</p>
        <p><strong>Si m ‚âà n¬≤:</strong> Considera <strong>Matriz de Adyacencia</strong> si necesitas O(1) en consultas</p>
        <p><strong>Si tienes multiaristas:</strong> Lista de Adyacencia es OBLIGATORIA (soporta naturalmente)</p>
        <p><strong>Si n < 1000 y necesitas simplicidad:</strong> Matriz puede ser aceptable (solo grafos simples)</p>
      </div>

      <div class="note" style="background:#fff3cd;border-left:5px solid #ffc107">
<strong>üìö Nota sobre Multigrafos:</strong>

Con <strong>matriz de adyacencia</strong>, cada celda mat[u][v] necesitar√≠a almacenar una LISTA de pesos, perdiendo la ventaja de O(1):
‚Ä¢ mat[F][E] = [2.0, 4.0] (lista de pesos)
‚Ä¢ Acceso ya no es O(1), necesitas recorrer la lista
‚Ä¢ Desperdicio de memoria aumenta (n¬≤ listas, muchas vac√≠as)

Con <strong>lista de adyacencia</strong>, es natural:
‚Ä¢ adj[F] = [(E, 2.0), (E, 4.0), (D, 5.0)]
‚Ä¢ Cada tupla (v, peso) es independiente
‚Ä¢ No se pierde eficiencia

<strong>Conclusi√≥n:</strong> Para multigrafos, lista de adyacencia es superior en todos los aspectos.
      </div>

      <h3>Ejemplo Num√©rico</h3>
      <div class="note">
<strong>Grafo con n = 10,000 v√©rtices:</strong>

Caso disperso (red social t√≠pica):
‚Ä¢ m = 50,000 aristas (cada persona conoce ~10 personas)
‚Ä¢ Matriz: 10,000¬≤ = 100,000,000 entradas ‚Üí ~400 MB (usando ints)
‚Ä¢ Lista: 10,000 + 50,000 = 60,000 entradas ‚Üí ~1 MB
‚Ä¢ <strong>Lista es 400√ó m√°s eficiente en memoria</strong>

Caso denso (grafo casi completo):
‚Ä¢ m = 49,995,000 aristas (99% de densidad)
‚Ä¢ Matriz: 100,000,000 entradas ‚Üí ~400 MB
‚Ä¢ Lista: 10,000 + 49,995,000 ‚âà 50,000,000 entradas ‚Üí ~200 MB
‚Ä¢ Lista sigue siendo mejor, pero la diferencia es menor
      </div>

      <button class="btn" onclick="showSection('proyecto')">Conexi√≥n con Proyecto ‚Üí</button>
    </section>

    <!-- PROYECTO -->
    <section id="proyecto" class="section">
      <h2>üß≠ Conexi√≥n al Proyecto Integrador</h2>
      
      <div class="challenge">
        <h3>Contexto del Proyecto</h3>
        <p>Desarrollar√°s un sistema completo de an√°lisis y optimizaci√≥n de redes urbanas que incluye:</p>
        <ul>
          <li><strong>Semana 3 (Actual):</strong> Modelado de red urbana como grafo mixto</li>
          <li><strong>Semana 4:</strong> Algoritmos de recorrido (BFS, DFS) para exploraci√≥n</li>
          <li><strong>Semana 5:</strong> Caminos m√°s cortos (Dijkstra, Bellman-Ford) para rutas √≥ptimas</li>
          <li><strong>Semana 6:</strong> √Årbol de expansi√≥n m√≠nima (Prim, Kruskal) para dise√±o de redes</li>
          <li><strong>Semana 7-8:</strong> Aplicaciones avanzadas (flujo m√°ximo, detecci√≥n de ciclos, componentes fuertemente conexas)</li>
        </ul>
      </div>

      <div class="activity">
        <h4>Entregable: Avance 1 - Modelado del Grafo Urbano</h4>
        <p><strong>Fecha l√≠mite:</strong> Fin de Semana 3</p>
        <p><strong>Valor:</strong> 15% de la calificaci√≥n del proyecto</p>
        
        <h5 style="margin-top:15px">üìã Requisitos Obligatorios:</h5>
        
        <p><strong>1. Dise√±o Conceptual (30 puntos)</strong></p>
        <ul>
          <li>Diagrama del mapa con <strong>m√≠nimo 8 v√©rtices</strong> (zonas/intersecciones)</li>
          <li>Al menos <strong>12 aristas</strong> (calles/conexiones):
            <ul>
              <li>M√≠nimo 7 bidireccionales</li>
              <li>M√≠nimo 5 dirigidas</li>
            </ul>
          </li>
          <li>Tabla completa con todas las aristas y sus pesos justificados</li>
          <li>Descripci√≥n de cada v√©rtice (qu√© representa: zona comercial, hospital, etc.)</li>
          <li><strong>An√°lisis del problema E-F:</strong> Si tu mapa tiene m√∫ltiples rutas entre el mismo par de v√©rtices, expl√≠calo</li>
        </ul>
        
        <p><strong>2. Implementaci√≥n en C# (35 puntos)</strong></p>
        <ul>
          <li>Clase <code>Graph&lt;string&gt;</code> completa y funcional con TODOS los m√©todos:
            <ul>
              <li>AddVertex, AddEdge (con prevenci√≥n de duplicados)</li>
              <li>HasEdge, Neighbors</li>
              <li>OutDegree, InDegree (cr√≠tico para grafos mixtos)</li>
              <li>RemoveEdge, RemoveVertex</li>
              <li>VertexCount, EdgeCount, Print</li>
            </ul>
          </li>
          <li>Programa principal que:
            <ul>
              <li>Carga tu mapa de ciudad completo</li>
              <li>Imprime estad√≠sticas (grados de todos los v√©rtices)</li>
              <li>Realiza al menos 5 consultas de existencia de aristas</li>
              <li>Demuestra eliminaci√≥n de una arista</li>
            </ul>
          </li>
          <li>C√≥digo con <strong>comentarios explicativos</strong> (no excesivos, pero claros)</li>
        </ul>
        
        <p><strong>3. Implementaci√≥n en Python (35 puntos)</strong></p>
        <ul>
          <li>Archivo <code>ciudad.txt</code> con tu mapa completo (12+ aristas)</li>
          <li>M√≥dulo <code>grafo.py</code> con TODAS las funciones:
            <ul>
              <li>create_graph, add_vertex, add_edge</li>
              <li>has_edge, neighbors</li>
              <li>out_degree, in_degree</li>
              <li>remove_edge, load_graph, print_graph</li>
            </ul>
          </li>
          <li>Script <code>main.py</code> que:
            <ul>
              <li>Carga desde archivo con manejo de errores</li>
              <li>Imprime el grafo completo</li>
              <li>Realiza an√°lisis de grados de todos los v√©rtices</li>
              <li>Detecta zonas cr√≠ticas (sin entradas o sin salidas)</li>
              <li>Si tienes m√∫ltiples rutas entre v√©rtices, las identifica autom√°ticamente</li>
            </ul>
          </li>
        </ul>
      </div>

      <div class="activity">
        <h4>üìä Formato del Reporte T√©cnico (Obligatorio)</h4>
        <p>Documento PDF de 3-5 p√°ginas que incluya:</p>
        
        <p><strong>Secci√≥n 1: Modelado del Problema</strong></p>
        <ul>
          <li>Descripci√≥n del contexto (ciudad, campus, red corporativa, etc.)</li>
          <li>Justificaci√≥n del tipo de grafo (¬øpor qu√© mixto? ¬øpor qu√© dirigido/no dirigido?)</li>
          <li>Explicaci√≥n de los pesos (distancias, tiempos, costos, etc.)</li>
        </ul>
        
        <p><strong>Secci√≥n 2: Elecci√≥n de Representaci√≥n</strong></p>
        <ul>
          <li>Comparaci√≥n Matriz vs Lista para TU caso espec√≠fico</li>
          <li>C√°lculo de memoria: O(n¬≤) vs O(n+m) con valores reales</li>
          <li>An√°lisis de operaciones frecuentes en tu aplicaci√≥n</li>
          <li><strong>Decisi√≥n final justificada</strong></li>
        </ul>
        
        <p><strong>Secci√≥n 3: An√°lisis de Complejidad</strong></p>
        <ul>
          <li>Tabla con complejidad de cada operaci√≥n en tu implementaci√≥n</li>
          <li>Identificaci√≥n de operaciones m√°s costosas</li>
          <li>Propuestas de optimizaci√≥n (si aplica)</li>
        </ul>
        
        <p><strong>Secci√≥n 4: Pruebas y Resultados</strong></p>
        <ul>
          <li>Capturas de pantalla de ambas implementaciones (C# y Python)</li>
          <li>Tabla comparativa de resultados (grados calculados en ambos lenguajes)</li>
          <li>An√°lisis del problema de m√∫ltiples rutas (si aplica en tu mapa)</li>
        </ul>
      </div>

      <div class="error-box">
        <h4>‚ö†Ô∏è Errores Comunes que Restan Puntos</h4>
        <ul>
          <li>‚ùå <strong>Permitir aristas duplicadas</strong> sin justificaci√≥n de multigrafo</li>
          <li>‚ùå <strong>No distinguir</strong> entre grado de entrada y salida</li>
          <li>‚ùå <strong>Olvidar agregar ambas direcciones</strong> en aristas bidireccionales</li>
          <li>‚ùå <strong>C√≥digo sin comentarios</strong> o con comentarios excesivos/redundantes</li>
          <li>‚ùå <strong>Implementaciones inconsistentes</strong> entre C# y Python</li>
          <li>‚ùå <strong>No validar entrada</strong> en carga de archivos</li>
          <li>‚ùå <strong>Reporte sin an√°lisis</strong> (solo copiar c√≥digo sin explicar)</li>
        </ul>
      </div>

      <div class="activity">
        <h4>‚úÖ Checklist de Validaci√≥n Pre-Entrega</h4>
        <p>Antes de entregar, verifica que:</p>
        <ul>
          <li>‚òê El grafo tiene m√≠nimo 8 v√©rtices y 12 aristas</li>
          <li>‚òê Incluye AMBOS tipos de aristas (dirigidas y bidireccionales)</li>
          <li>‚òê Las implementaciones en C# y Python dan los <strong>mismos resultados</strong></li>
          <li>‚òê Los grados calculados coinciden entre ambos lenguajes</li>
          <li>‚òê No hay aristas duplicadas (o est√°n justificadas como multigrafo)</li>
          <li>‚òê Todos los m√©todos/funciones requeridos est√°n implementados</li>
          <li>‚òê El c√≥digo compila/ejecuta sin errores</li>
          <li>‚òê El archivo de texto se carga correctamente</li>
          <li>‚òê El reporte incluye TODAS las secciones requeridas</li>
          <li>‚òê Hay capturas de pantalla de ambas implementaciones</li>
          <li>‚òê La justificaci√≥n de representaci√≥n (matriz vs lista) es t√©cnica y espec√≠fica</li>
        </ul>
      </div>

      <div class="note">
<strong>üí° Consejo Profesional:</strong> 

Este avance es la BASE de todo tu proyecto. Invierte tiempo en un buen dise√±o ahora, porque las pr√≥ximas semanas construir√°s sobre esta estructura. Un grafo mal modelado dificultar√° la implementaci√≥n de algoritmos de b√∫squeda y optimizaci√≥n.

<strong>Estrategia recomendada:</strong>
1. Empieza con el ejemplo de la ciudad de este documento
2. Modif√≠calo gradualmente para tu propio caso
3. Prueba CADA modificaci√≥n antes de continuar
4. Usa control de versiones (Git) para no perder tu trabajo
      </div>

      <div style="text-align:center;margin-top:20px">
        <button class="btn btn-success" onclick="alert('¬°Excelente! Has completado la Semana 3.\\n\\nRecuerda:\\n‚Ä¢ Guarda tu c√≥digo en repositorio Git\\n‚Ä¢ Documenta todo claramente\\n‚Ä¢ Prepara tu entregable antes de la fecha l√≠mite\\n\\n¬°√âxito en tu proyecto!')">‚úì Marcar Semana 3 como Completada</button>
        <button class="btn" onclick="showSection('introduccion')">üîÑ Volver al Inicio</button>
      </div>
    </section>
  </div>

  <script>
    let currentSection = 'introduccion';
    const sections = ['introduccion','conceptos','representaciones','problema','cs','py','actividades','comparacion','proyecto'];

    function showSection(name){
      document.querySelectorAll('.section').forEach(s=>s.classList.remove('active'));
      const targetSection = document.getElementById(name);
      if(targetSection){
        targetSection.classList.add('active','fade-in');
      }
      document.querySelectorAll('.nav-link').forEach(l=>l.classList.remove('active'));
      const navLink = document.querySelector(`[onclick="showSection('${name}')"]`);
      if(navLink) navLink.classList.add('active');
      updateProgress(name);
      currentSection=name;
      window.scrollTo({top:0, behavior:'smooth'});
    }
    
    function updateProgress(name){
      const i = sections.indexOf(name);
      const progress = i >= 0 ? ((i+1)/sections.length)*100 : 0;
      document.getElementById('progress').style.width = progress + '%';
    }

    // Navegaci√≥n con teclado
    document.addEventListener('keydown',(e)=>{
      const i = sections.indexOf(currentSection);
      if(e.key==='ArrowRight' && i < sections.length-1) showSection(sections[i+1]);
      else if(e.key==='ArrowLeft' && i>0) showSection(sections[i-1]);
    });

    // Easter egg con tip educativo
    let seq=[]; 
    const KONAMI=['ArrowUp','ArrowUp','ArrowDown','ArrowDown','ArrowLeft','ArrowRight','ArrowLeft','ArrowRight','KeyB','KeyA'];
    document.addEventListener('keydown',(e)=>{
      seq.push(e.code); 
      if(seq.length>KONAMI.length) seq.shift();
      if(seq.join(',')===KONAMI.join(',')){
        alert('üéÆ ¬°C√≥digo Konami desbloqueado!\n\nüí° Tip de Grafos:\n\n' +
              'Para grafos dispersos (m ‚â™ n¬≤), la lista de adyacencia es casi siempre superior.\n' +
              'La mayor√≠a de grafos del mundo real son dispersos:\n' +
              '‚Ä¢ Redes sociales\n' +
              '‚Ä¢ Mapas de carreteras\n' +
              '‚Ä¢ Internet\n' +
              '‚Ä¢ Redes biol√≥gicas\n\n' +
              '¬°Usa listas de adyacencia por defecto!');
        seq=[];
      }
    });

    updateProgress('introduccion');
  </script>
</body>
</html>